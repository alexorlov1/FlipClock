## API Report File for "flipclock"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function add(date: Date, duration: Partial<Duration>): Date;

// @public
export function addDays(date: Date, amount: number): Date;

// @public
export function addMonths(date: Date, amount: number): Date;

// Warning: (ae-forgotten-export) The symbol "Face" needs to be exported by the entry point index.d.ts
//
// @public
export class Alphanumeric implements Face {
    constructor(props: AlphanumericProps);
    afterCreate(instance: FlipClock<any>): void;
    get backwards(): boolean;
    readonly direction: 'auto' | 'forwards' | 'backwards';
    interval(instance: FlipClock<any>): void;
    readonly sequencer: SequencerContext;
    readonly skipChars?: number;
    targetValue: FaceValue<string | DigitizedValues>;
    value: FaceValue<string | DigitizedValues>;
}

// @public
export function alphanumeric(props: AlphanumericProps): Alphanumeric;

// @public (undocumented)
export type AlphanumericProps = {
    value: FaceValue<string | DigitizedValues>;
    direction?: 'auto' | 'forwards' | 'backwards';
    targetValue: FaceValue<string | DigitizedValues>;
    sequencer?: SequencerContext | SequencerOptions;
    skipChars?: number;
};

// @public (undocumented)
export type Callback<P extends CallbackParams<any[]>, R = undefined> = (...args: P) => R;

// @public (undocumented)
export type CallbackParams<T> = T extends any[] ? T : never;

// @public
export function castDigitizedGroup(value?: DigitizedValue | DigitizedValues): DigitizedValues;

// @public
export function castDigitizedString(value?: DigitizedValue | DigitizedValues): DigitizedValue | undefined;

// @public
export function castDigitizedValues(value?: DigitizedValue | DigitizedValues): DigitizedValue[];

// @public (undocumented)
export type Change<R> = {
    from: R;
    to: R;
};

// @public
export function characterRange(startChar: string, endChar: string): string[];

// @public (undocumented)
export type CharsetCache = Map<string, string[]>;

// @public (undocumented)
export type CharsetContext = {
    charset: string[];
    emptyChar: string;
    chunk: ChunkFunction;
    isBlacklisted: IsBlacklistFunction;
    isWhitelisted: IsWhitelistFunction;
    next: NextFunction;
    prev: PrevFunction;
};

// @public (undocumented)
export type CharsetOptions = {
    whitelist?: string[];
    blacklist?: string[];
    charset?: CreateCharset;
    emptyChar?: string;
    shuffle?: boolean | ShuffleFunction;
};

// @public (undocumented)
export type ChunkFunction = (value: DigitizedValue | undefined, size: number) => string[];

// @public
export function classes(values?: HTMLClassAttribute): string;

// @public
export class Clock implements Face {
    constructor(props?: ClockProps);
    date?: Date;
    format: string;
    formatter: UseDateFormats;
    interval(instance: FlipClock<any>): void;
    value: FaceValue<string>;
}

// @public
export function clock(props?: ClockProps): Clock;

// @public (undocumented)
export type ClockProps = {
    date?: Date;
    format?: string;
    formatter?: UseDateFormats | DateFormatOptions;
};

// @public
export function compareAsc(left: Date, right: Date): number;

// @public (undocumented)
export function computed<T>(proxy: ComputedGetterSetter<T>): WriteableComputedRef<T>;

// @public (undocumented)
export function computed<T>(fn: ComputedGetter<T>): ComputedRef<T>;

// @public (undocumented)
export type ComputedGetter<T> = () => T;

// @public (undocumented)
export type ComputedGetterSetter<T> = {
    get(): T;
    set(value: T): void;
};

// @public (undocumented)
export type ComputedRef<T> = Readonly<Ref<T>>;

// @public
export class Counter implements Face {
    constructor(props: CounterProps);
    countdown: boolean;
    decrement(value?: number): void;
    increment(value?: number): void;
    interval(): void;
    step: number;
    targetValue?: FaceValue<number>;
    value: FaceValue<number>;
}

// @public
export function counter(props: CounterProps): Counter;

// @public (undocumented)
export type CounterProps = {
    countdown?: boolean;
    value: FaceValue<number>;
    sequencer?: SequencerContext;
    step?: number;
    targetValue?: FaceValue<number>;
} & SequencerOptions;

// @public (undocumented)
export type CreateCharset = (shuffle?: boolean) => string[];

// @public (undocumented)
export function createSignal<T>(initialValue: T): Signal<T>;

// @public (undocumented)
export function createSignal<T>(initialValue?: T): Signal<T | undefined>;

// @public (undocumented)
export type DateFlagFormatter = (date: Date) => string;

// @public (undocumented)
export type DateFormatOptions = {
    translate?: Translator;
    formats?: Record<string, DateFlagFormatter>;
};

// @public (undocumented)
export type DateFormatter = (date: Date, format: string) => string;

// @public (undocumented)
export type DateMapDefinition = Map<string, DateFlagFormatter>;

// @public
export const dayAbbreviations: string[];

// @public
export const days: string[];

// @public
export const daysInWeek: number;

// @public (undocumented)
export function debounce(fn: Function, ms?: number): (this: any, ...args: any[]) => void;

// @public (undocumented)
export type DecrementFunction = (current: FaceValue<any>, target: FaceValue<any>, count?: number, backwards?: boolean) => FaceValue<any>;

// @public
export function defaultCharset(): string[];

// @public (undocumented)
export type DefineFunction<V> = (key: string | Record<string, V>, value?: V) => void;

// @public (undocumented)
export type DefinitionTerms = Record<string, string | Translator>;

// @public (undocumented)
export type DictionaryMap = Map<string, string | Translator>;

// @public (undocumented)
export type DictionaryRecord = Record<string, string | Translator>;

// @public
export function differenceInCalendarMonths(left: Date, right: Date): number;

// @public
export function differenceInCalendarYears(left: Date, right: Date): number;

// @public
export function differenceInDays(left: Date, right: Date): number;

// @public
export function differenceInHours(left: Date, right: Date): number;

// @public
export function differenceInMilliseconds(dirtyLeft: Date, dirtyRight: Date): number;

// @public
export function differenceInMinutes(left: Date, right: Date): number;

// @public
export function differenceInMonths(dirtyLeft: Date, dirtyRight: Date): number;

// @public
export function differenceInSeconds(left: Date, right: Date): number;

// @public
export function differenceInWeeks(dirtyLeft: Date, dirtyRight: Date): number;

// @public
export function differenceInYears(dirtyLeft: Date, dirtyRight: Date): number;

// @public (undocumented)
export type DigitizedValue = string;

// @public (undocumented)
export type DigitizedValues = (DigitizedValue | DigitizedValues)[];

// @public (undocumented)
export type DigitizeFunction = (value: any) => DigitizedValues;

// @public (undocumented)
export type DigitizerContext = {
    digitize: DigitizeFunction;
    undigitize: UndigitizeFunction;
    isDigitized: IsDigitizedFunction;
};

// @public (undocumented)
export type Duration = {
    years?: number;
    months?: number;
    weeks?: number;
    days?: number;
    hours?: number;
    minutes?: number;
    seconds?: number;
    milliseconds?: number;
};

// @public (undocumented)
export type DurationFlagFormats = Record<string, DurationFlagFormatter>;

// @public (undocumented)
export type DurationFlagFormatter = (duration: Duration, length: number) => string;

// @public (undocumented)
export type DurationFormatOptions = {
    translate?: Translator;
    formats?: DurationFlagFormats;
};

// @public (undocumented)
export type DurationFormatter = (date: Duration, format: string) => string;

// @public (undocumented)
export type DurationMapDefinition = [keyof Duration | (keyof Duration)[], DurationFlagFormatter];

// @public
export function el<T extends keyof HTMLElementTagNameMap>(options: ElementOptions<T>): HTMLElementTagNameMap[T];

// @public
export class ElapsedTime implements Face {
    constructor(props: ElapsedTimeProps);
    end?: Date;
    format: string;
    formatter: UseDurationFormats;
    interval(): void;
    get span(): {
        start: Date;
        end: Date;
    };
    start?: Date;
    value: FaceValue<string>;
}

// @public
export function elapsedTime(props: ElapsedTimeProps): ElapsedTime;

// @public (undocumented)
export type ElapsedTimeProps = {
    end?: Date;
    format: string;
    formatter?: UseDurationFormats | DurationFormatOptions;
    start?: Date;
};

// @public (undocumented)
export type ElementChildElement = ChildNode | string | undefined | null | false;

// @public (undocumented)
export type ElementChildren = (ElementChildElement)[] | ((el: Element) => ElementChildElement[]);

// @public (undocumented)
export type ElementOptions<T> = {
    tagName: T;
    el?: ChildNode | Element | null;
    class?: HTMLClassAttribute;
    style?: HTMLStyleAttribute;
    attrs?: HTMLAttributes;
    children?: ElementChildren;
    events?: {
        [K in keyof GlobalEventHandlers]?: GlobalEventHandlers[K];
    };
};

// @public
export const EMPTY_CHAR = " ";

// @public
export function endOfDay(date: Date): Date;

// @public
export function endOfMonth(date: Date): Date;

// @public (undocumented)
type Event_2<T, K extends keyof T> = {
    key: keyof T;
    fn: EventEmitterCallback<T, K>;
    unwatch: Function;
};
export { Event_2 as Event }

// @public
export class EventEmitter<T> {
    emit<K extends keyof Required<T>>(key: K, ...args: Required<T>[K] extends (...args: infer P) => void ? P : any[]): void;
    // (undocumented)
    protected events: Event_2<T, any>[];
    off<K extends keyof Required<T>>(key: K): void;
    on<K extends keyof Required<T>>(key: K, fn: EventEmitterCallback<T, K>): () => void;
    once<K extends keyof Required<T>>(key: K, fn: EventEmitterCallback<T, K>): void;
    unwatch(): void;
}

// @public (undocumented)
export type EventEmitterCallback<T, K extends keyof Required<T>> = (...args: Required<T>[K][]) => void;

// @public
export class FaceValue<T> {
    protected $carryLength: number;
    protected $value: Ref<T>;
    constructor(value: T, props?: FaceValueProps);
    // (undocumented)
    get carryLength(): number;
    compare(subject: FaceValue<any>): boolean;
    copy(value?: T, props?: FaceValueProps): FaceValue<T>;
    readonly digitizer: DigitizerContext;
    // (undocumented)
    get digits(): DigitizedValues;
    set digits(value: DigitizedValues);
    // (undocumented)
    get length(): number;
    // (undocumented)
    get minimumLength(): number;
    // (undocumented)
    get value(): T;
    set value(value: T);
}

// @public
export function faceValue<T>(value: T): FaceValue<T>;

// @public (undocumented)
export type FaceValueProps = {
    digitizer?: DigitizerContext;
};

// @public
export function fisherYatesShuffle(chars: string[]): string[];

// @public
export class FlipClock<T extends Face<T>> {
    constructor(props: FlipClockProps<T>);
    // (undocumented)
    get animationRate(): number;
    readonly autoStart: boolean;
    el?: Element | null;
    // Warning: (ae-forgotten-export) The symbol "FaceHooks" needs to be exported by the entry point index.d.ts
    readonly emitter: EventEmitter<FaceHooks<T>>;
    readonly face: T;
    protected hook<K extends keyof Required<FaceHooks<T>>>(key: K, ...args: Required<FaceHooks<T>>[K] extends (...args: infer P) => void ? P : any[]): void;
    mount(el: Element): this;
    start(fn?: (instance: FlipClock<T>) => void): this;
    stop(fn?: (instance: FlipClock<T>) => void): this;
    readonly theme: Theme<T>;
    readonly timer: Timer;
    toggle(fn?: (instance: FlipClock<T>) => void): this;
    unmount(): this;
}

// @public
export function flipClock<T extends Face<T>>(props: FlipClockProps<T>): FlipClock<T>;

// @public (undocumented)
export type FlipClockProps<T extends Face<T>> = {
    autoStart?: boolean;
    emitter?: EventEmitter<FaceHooks<T>>;
    face: T;
    theme?: Theme<T>;
    timer?: Timer | number;
    el?: Element | null;
};

// @public
export function getTwelveHourFormat(date: Date): string;

// @public (undocumented)
export type HTMLAttributes = Record<string, string>;

// @public (undocumented)
export type HTMLClassAttribute = string | string[] | Record<string, boolean | undefined | null>;

// @public (undocumented)
export type HTMLStyleAttribute = {
    [K in keyof CSSStyleDeclaration]?: string;
} | string;

// @public (undocumented)
export type IncrementFunction = (current: FaceValue<any>, target: FaceValue<any>, count?: number, backwards?: boolean) => FaceValue<any>;

// @public (undocumented)
export type IsBlacklistFunction = (value: DigitizedValue) => boolean;

// @public (undocumented)
export type IsDigitizedFunction = (value: any) => boolean;

// @public
export function isDigitizedGroup(value: DigitizedValues | DigitizedValue | undefined): boolean;

// @public
export function isDigitizedValues(value: DigitizedValue | DigitizedValues): boolean;

// @public
export function isLastDayOfMonth(dirtyDate: Date): boolean;

// @public (undocumented)
export type IsWhitelistFunction = (value: DigitizedValue) => boolean;

// @public (undocumented)
export function matchArrayStructure(current: DigitizedValues, target: DigitizedValues, fn?: MatchArrayStructureCallback): DigitizedValues;

// @public (undocumented)
export function matchArrayStructure(current: DigitizedValues, target: DigitizedValues, options: MatchArrayStructureOptions | undefined, fn?: MatchArrayStructureCallback): DigitizedValues;

// @public (undocumented)
export type MatchArrayStructureCallback = Callback<[value?: DigitizedValue, target?: DigitizedValue | DigitizedValues], DigitizedValue | undefined>;

// @public
export type MatchArrayStructureOptions = {
    backwards?: boolean;
};

// @public
export const millisecondsInDay: number;

// @public
export const millisecondsInHour: number;

// @public
export const millisecondsInMinute: number;

// @public
export const monthAbbreviations: string[];

// @public
export const months: string[];

// @public (undocumented)
export type NextFunction = (value?: DigitizedValue, target?: DigitizedValue | DigitizedValues, count?: number) => DigitizedValue | undefined;

// @public
export function pad(value: string | number | undefined, length: number): string;

// @public (undocumented)
export type PadFunction = (value: DigitizedValues, minimumDigits: number) => DigitizedValues;

// @public (undocumented)
export type PrevFunction = (value?: DigitizedValue, target?: DigitizedValue | DigitizedValues, count?: number) => DigitizedValue | undefined;

// @public
export function range(startAt: number | undefined, size: number): number[];

// @public (undocumented)
export type ReadFunction<T> = () => T;

// @public (undocumented)
export type Ref<T> = {
    value: T;
};

// @public (undocumented)
export function ref<T>(value: T): Ref<T>;

// @public (undocumented)
export function ref<T>(value?: T): Ref<T | undefined>;

// @public (undocumented)
export type ResetFunction<T> = () => T;

// @public (undocumented)
export type SequencerContext = {
    charset: string[];
    decrement: DecrementFunction;
    increment: IncrementFunction;
};

// @public (undocumented)
export type SequencerOptions = {
    charset?: CharsetContext | CharsetOptions;
    matchArray?: MatchArrayStructureOptions;
    stopWhen?: StopPredicateFunction<[current?: DigitizedValue, target?: DigitizedValue | DigitizedValues]>;
    stopAfterChanges?: number;
};

// @public (undocumented)
export type ShuffleFunction = (chars: string[]) => string[];

// @public (undocumented)
export type Signal<T> = [ReadFunction<T>, WriteFunction<T>, ResetFunction<T>];

// @public
export function sort(map: Map<string, unknown>): string[];

// @public (undocumented)
export type Stop = Readonly<{
    stop: true;
}>;

// @public (undocumented)
function stop_2(): Stop;
export { stop_2 as stop }

// @public
export function stopAfterChanges<P extends CallbackParams<any[]>, R>(totalChanges: number, fn: Callback<P, R>): Callback<P, R>;

// @public (undocumented)
export type StopPredicateFunction<P extends CallbackParams<any[]> = any[]> = TrackChangesCallback<P, boolean>;

// @public
export function stopWhen<P extends CallbackParams<any[]>, R>(predicate: StopPredicateFunction<P>, fn: Callback<P, R>): Callback<P, R>;

// @public
export function style(value: HTMLStyleAttribute): string;

// @public (undocumented)
export type Theme<T extends Face<T>> = {
    render: (instance: FlipClock<T>) => void;
} & FaceHooks<T>;

// Warning: (ae-forgotten-export) The symbol "FlipClockThemeOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function theme(options?: FlipClockThemeOptions): {
    render: (instance: FlipClock<any>) => HTMLDivElement;
};

// @public
export class Timer {
    protected $count: number;
    protected $handle?: number;
    protected $lastLoop?: number;
    protected $startDate?: Date;
    constructor(interval?: number);
    get count(): number;
    get elapsed(): number;
    get elapsedSinceLastLoop(): number;
    readonly interval: number;
    get isRunning(): boolean;
    get isStopped(): boolean;
    get lastLoop(): number;
    reset(fn?: (timer: Timer) => void): Timer;
    start(fn?: (timer: Timer) => void): Timer;
    get started(): Date | undefined;
    stop(fn?: (timer: Timer) => void): Timer;
}

// @public
export function timer(interval?: number): Timer;

// @public
export function trackChanges<P extends any[], R>(fn: TrackChangesCallback<P, R>): Callback<P, R>;

// @public (undocumented)
export type TrackChangesCallback<P extends any[], R, C = P[0] | undefined> = (changes: Change<C>[], ...args: P) => R | Stop;

// @public (undocumented)
export type Translator = (value: string) => string;

// @public (undocumented)
export type UndigitizeFunction = (value: DigitizedValues) => string | DigitizedValues;

// @public (undocumented)
export type UnsetFunction = (key: string | string[]) => void;

// @public
export function useCharset(options?: CharsetOptions): CharsetContext;

// @public (undocumented)
export type UseDateFormats = {
    map: DateMapDefinition;
    define: DefineFunction<DateFlagFormatter>;
    format: DateFormatter;
    unset: UnsetFunction;
};

// @public
export function useDateFormats(options?: DateFormatOptions): UseDateFormats;

// @public (undocumented)
export type UseDefinitionMap<V> = {
    map: Map<string, V>;
    define: (key: string | Record<string, V>, value?: V) => void;
    unset: (keys: string | string[]) => void;
};

// @public
export function useDefinitionMap<V>(items: [string, V][]): UseDefinitionMap<V>;

// @public
export function useDictionary(definitions?: DefinitionTerms): {
    map: Map<string, string | Translator>;
    define: (key: string | Record<string, string | Translator>, value?: string | Translator | undefined) => void;
    translate: (key: string) => string;
    unset: (keys: string | string[]) => void;
};

// @public
export function useDigitizer(): DigitizerContext;

// @public (undocumented)
export type UseDurationFormats = {
    map: Map<string, DurationMapDefinition>;
    define: DefineFunction<DurationMapDefinition>;
    duration: (left: Date, right: Date, keys?: (keyof Duration)[]) => Duration;
    format: (left: Date, right: Date, format: string) => string;
    unset: UnsetFunction;
};

// @public (undocumented)
export function useDurationFormats(options?: DurationFormatOptions): UseDurationFormats;

// @public (undocumented)
export function useSequencer(options?: SequencerOptions): SequencerContext;

// @public (undocumented)
export function watchEffect(callback: () => void): void;

// @public (undocumented)
export type WriteableComputedRef<T> = Ref<T>;

// @public (undocumented)
export type WriteFunction<T> = (value: T) => void;

// (No @packageDocumentation comment for this package)

```
